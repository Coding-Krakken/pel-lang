// PEL Standard Library - Cashflow Module
// Financial modeling functions for cash flow analysis, working capital, burn rate, and runway

// === Accounts Receivable (AR) Functions ===

func ar_with_payment_terms(
  revenue: Currency<USD> per Month,
  payment_terms_days: Duration<Day>
) -> Currency<USD> {
  // Calculate accounts receivable based on payment terms
  // AR = revenue * (payment_terms / 30 days)
  // Assumes 30-day month for calculation
  return revenue * (payment_terms_days / 30day)
}

func ar_aging_buckets(
  total_ar: Currency<USD>,
  current_pct: Fraction,
  aged_30_pct: Fraction,
  aged_60_pct: Fraction,
  aged_90_pct: Fraction
) -> Currency<USD> {
  // Calculate AR aging - returns total aged AR (30+ days)
  // Returns sum of aged buckets for risk assessment
  var aged_ar = total_ar * (aged_30_pct + aged_60_pct + aged_90_pct)
  return aged_ar
}

func days_sales_outstanding(
  accounts_receivable: Currency<USD>,
  revenue: Currency<USD> per Month
) -> Duration<Day> {
  // DSO = (AR / Revenue) * 30 days
  // Measures average collection period
  var dso_ratio: Fraction = accounts_receivable / revenue
  return dso_ratio * 30day
}

func bad_debt_reserve(
  accounts_receivable: Currency<USD>,
  reserve_rate: Fraction
) -> Currency<USD> {
  // Calculate bad debt reserve
  // Reserve = AR * reserve_rate
  return accounts_receivable * reserve_rate
}

// === Accounts Payable (AP) Functions ===

func ap_with_payment_terms(
  expenses: Currency<USD> per Month,
  payment_terms_days: Duration<Day>
) -> Currency<USD> {
  // Calculate accounts payable based on payment terms
  // AP = expenses * (payment_terms / 30 days)
  return expenses * (payment_terms_days / 30day)
}

func ap_aging_buckets(
  total_ap: Currency<USD>,
  current_pct: Fraction,
  aged_30_pct: Fraction,
  aged_60_pct: Fraction,
  aged_90_pct: Fraction
) -> Currency<USD> {
  // Calculate AP aging - returns total overdue AP (30+ days)
  var overdue_ap = total_ap * (aged_30_pct + aged_60_pct + aged_90_pct)
  return overdue_ap
}

func days_payable_outstanding(
  accounts_payable: Currency<USD>,
  expenses: Currency<USD> per Month
) -> Duration<Day> {
  // DPO = (AP / Expenses) * 30 days
  // Measures average payment period
  var dpo_ratio: Fraction = accounts_payable / expenses
  return dpo_ratio * 30day
}

// === Payroll Functions ===

func payroll_timing(
  headcount: Count<Employee>,
  annual_salary_per_employee: Currency<USD> per Year per Employee,
  payment_frequency_days: Duration<Day>
) -> Currency<USD> per Month {
  // Calculate monthly payroll expense
  // Monthly payroll = (headcount * annual_salary / 12 months)
  var monthly_payroll = (headcount * annual_salary_per_employee) / 12mo
  return monthly_payroll
}

func payroll_taxes_timing(
  gross_payroll: Currency<USD> per Month,
  tax_rate: Fraction
) -> Currency<USD> per Month {
  // Calculate payroll tax liability
  // Tax = gross_payroll * tax_rate
  return gross_payroll * tax_rate
}

func payroll_accrued(
  monthly_payroll: Currency<USD> per Month,
  days_accrued: Duration<Day>
) -> Currency<USD> {
  // Calculate accrued payroll liability
  // Accrued = monthly_payroll * (days_accrued / 30 days)
  return monthly_payroll * (days_accrued / 30day)
}

// === Working Capital Functions ===

func working_capital(
  current_assets: Currency<USD>,
  current_liabilities: Currency<USD>
) -> Currency<USD> {
  // Working capital = current assets - current liabilities
  return current_assets - current_liabilities
}

func cash_conversion_cycle(
  days_sales_outstanding: Duration<Day>,
  days_inventory_outstanding: Duration<Day>,
  days_payable_outstanding: Duration<Day>
) -> Duration<Day> {
  // CCC = DSO + DIO - DPO
  // Measures time between paying suppliers and collecting from customers
  return days_sales_outstanding + days_inventory_outstanding - days_payable_outstanding
}

func burn_rate(
  starting_cash: Currency<USD>,
  ending_cash: Currency<USD>,
  period_months: Count<Month>
) -> Currency<USD> per Month {
  // Monthly burn rate = (starting - ending) / months
  var total_burn = starting_cash - ending_cash
  return total_burn / period_months
}

func runway_months(
  current_cash: Currency<USD>,
  monthly_burn_rate: Currency<USD> per Month
) -> Duration<Month> {
  // Runway = cash / burn_rate
  // Returns months until cash runs out
  var runway_ratio: Fraction = current_cash / monthly_burn_rate
  return runway_ratio * 1mo
}

// === Cash Waterfall Functions ===

func operating_cash_flow(
  net_income: Currency<USD> per Month,
  depreciation: Currency<USD> per Month,
  change_in_working_capital: Currency<USD>
) -> Currency<USD> per Month {
  // OCF = net income + depreciation - change in WC
  // Note: change_in_WC is converted to monthly basis
  var wc_monthly = change_in_working_capital / 1mo
  return net_income + depreciation - wc_monthly
}

func free_cash_flow(
  operating_cash_flow: Currency<USD> per Month,
  capital_expenditures: Currency<USD> per Month
) -> Currency<USD> per Month {
  // FCF = OCF - CapEx
  return operating_cash_flow - capital_expenditures
}

func cash_balance_projection(
  starting_cash: Currency<USD>,
  operating_cash_flow: Currency<USD> per Month,
  financing_cash_flow: Currency<USD> per Month,
  projection_months: Count<Month>
) -> Currency<USD> {
  // Project ending cash balance
  // Ending = Starting + (OCF + Financing) * months
  var net_monthly_flow = operating_cash_flow + financing_cash_flow
  var total_flow = net_monthly_flow * projection_months
  return starting_cash + total_flow
}

// === Additional Working Capital Metrics ===

func net_working_capital_ratio(
  working_capital: Currency<USD>,
  revenue: Currency<USD> per Month
) -> Fraction {
  // NWC ratio = working capital / monthly revenue
  // Measures efficiency of working capital usage
  return working_capital / revenue
}

func current_ratio(
  current_assets: Currency<USD>,
  current_liabilities: Currency<USD>
) -> Fraction {
  // Current ratio = current assets / current liabilities
  // Healthy if >= 1.5
  return current_assets / current_liabilities
}

func quick_ratio_cashflow(
  cash: Currency<USD>,
  accounts_receivable: Currency<USD>,
  current_liabilities: Currency<USD>
) -> Fraction {
  // Quick ratio = (cash + AR) / current liabilities
  // More conservative than current ratio (excludes inventory)
  var liquid_assets = cash + accounts_receivable
  return liquid_assets / current_liabilities
}
