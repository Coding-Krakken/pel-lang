// PEL Standard Library - Cashflow Module
// Cashflow timing, working capital, and runway calculations

// === Accounts Receivable (AR) Functions ===

func ar_with_payment_terms(
  revenue: Currency<USD> per Month,
  payment_terms: Duration<Day>
) -> Currency<USD> {
  // Calculate accounts receivable based on payment terms
  // AR = Revenue * (Payment Terms / 30 days)
  // Assumes monthly revenue cycle
  var days_in_month: Duration<Day> = 30d
  return revenue * (payment_terms / days_in_month)
}

func ar_aging_buckets(
  total_ar: Currency<USD>,
  current_pct: Fraction,
  aged_30_pct: Fraction,
  aged_60_pct: Fraction,
  aged_90_pct: Fraction
) -> Currency<USD> {
  // Calculate weighted AR considering aging buckets
  // Returns expected collectible amount with aging adjustment
  // Assumes collection rates: current=100%, 30d=95%, 60d=85%, 90d=70%
  var current_collectible: Fraction = 1.0
  var aged_30_collectible: Fraction = 0.95
  var aged_60_collectible: Fraction = 0.85
  var aged_90_collectible: Fraction = 0.70
  
  var weighted_ar = 
    (total_ar * current_pct * current_collectible) +
    (total_ar * aged_30_pct * aged_30_collectible) +
    (total_ar * aged_60_pct * aged_60_collectible) +
    (total_ar * aged_90_pct * aged_90_collectible)
  
  return weighted_ar
}

func days_sales_outstanding(
  accounts_receivable: Currency<USD>,
  revenue: Currency<USD> per Month
) -> Duration<Day> {
  // Calculate DSO: (AR / Monthly Revenue) * 30 days
  // Indicates average collection period
  var days_in_month: Duration<Day> = 30d
  return (accounts_receivable / revenue) * days_in_month
}

func bad_debt_reserve(
  accounts_receivable: Currency<USD>,
  reserve_rate: Fraction
) -> Currency<USD> {
  // Calculate bad debt reserve
  // Typical reserve rates: 1-5% depending on industry
  return accounts_receivable * reserve_rate
}

// === Accounts Payable (AP) Functions ===

func ap_with_payment_terms(
  expenses: Currency<USD> per Month,
  payment_terms: Duration<Day>
) -> Currency<USD> {
  // Calculate accounts payable based on payment terms
  // AP = Expenses * (Payment Terms / 30 days)
  var days_in_month: Duration<Day> = 30d
  return expenses * (payment_terms / days_in_month)
}

func ap_aging_buckets(
  total_ap: Currency<USD>,
  current_pct: Fraction,
  aged_30_pct: Fraction,
  aged_60_pct: Fraction,
  aged_90_pct: Fraction
) -> Currency<USD> {
  // Calculate total AP liability considering aging
  // All AP must be paid, so no discount applied
  return total_ap
}

func days_payable_outstanding(
  accounts_payable: Currency<USD>,
  expenses: Currency<USD> per Month
) -> Duration<Day> {
  // Calculate DPO: (AP / Monthly Expenses) * 30 days
  // Indicates average payment period to suppliers
  var days_in_month: Duration<Day> = 30d
  return (accounts_payable / expenses) * days_in_month
}

// === Payroll Functions ===

func payroll_timing(
  headcount: Count<Employee>,
  avg_salary: Currency<USD> per Month per Employee,
  payment_frequency: Duration<Day>
) -> Currency<USD> per Month {
  // Calculate monthly payroll based on headcount and frequency
  // Payment frequency doesn't affect monthly total, only timing
  return headcount * avg_salary
}

func payroll_taxes_timing(
  payroll: Currency<USD> per Month,
  tax_rate: Fraction,
  payment_delay: Duration<Day>
) -> Currency<USD> per Month {
  // Calculate payroll tax liability
  // Payment delay affects cash timing but not monthly amount
  return payroll * tax_rate
}

func payroll_accrued(
  payroll: Currency<USD> per Month,
  accrual_days: Duration<Day>
) -> Currency<USD> {
  // Calculate accrued payroll liability
  // Represents earned but unpaid wages
  var days_in_month: Duration<Day> = 30d
  return payroll * (accrual_days / days_in_month)
}

// === Working Capital Functions ===

func working_capital(
  current_assets: Currency<USD>,
  current_liabilities: Currency<USD>
) -> Currency<USD> {
  // Working Capital = Current Assets - Current Liabilities
  // Positive indicates liquidity buffer
  return current_assets - current_liabilities
}

func cash_conversion_cycle(
  days_sales_outstanding: Duration<Day>,
  days_inventory_outstanding: Duration<Day>,
  days_payable_outstanding: Duration<Day>
) -> Duration<Day> {
  // CCC = DSO + DIO - DPO
  // Lower is better (faster cash conversion)
  return days_sales_outstanding + days_inventory_outstanding - days_payable_outstanding
}

func burn_rate(
  starting_cash: Currency<USD>,
  ending_cash: Currency<USD>,
  period: Duration<Month>
) -> Currency<USD> per Month {
  // Calculate cash burn rate
  // Negative indicates net cash consumption
  var cash_change = ending_cash - starting_cash
  return cash_change / period
}

func runway_months(
  cash_balance: Currency<USD>,
  monthly_burn: Currency<USD> per Month
) -> Duration<Month> {
  // Calculate months of runway remaining
  // Assumes constant burn rate
  return cash_balance / monthly_burn
}

// === Cash Waterfall Functions ===

func operating_cash_flow(
  net_income: Currency<USD> per Month,
  depreciation: Currency<USD> per Month,
  working_capital_change: Currency<USD> per Month
) -> Currency<USD> per Month {
  // OCF = Net Income + Depreciation - WC Change
  // Add back non-cash expenses, subtract WC increase
  return net_income + depreciation - working_capital_change
}

func free_cash_flow(
  operating_cash_flow: Currency<USD> per Month,
  capital_expenditures: Currency<USD> per Month
) -> Currency<USD> per Month {
  // FCF = OCF - CapEx
  // Cash available after maintaining operations
  return operating_cash_flow - capital_expenditures
}

func cash_balance_projection(
  starting_cash: Currency<USD>,
  monthly_cash_flow: Currency<USD> per Month,
  periods: Count<Month>
) -> Currency<USD> {
  // Project ending cash balance over periods
  // Simplified linear projection
  return starting_cash + (monthly_cash_flow * periods)
}
